# Guide for Creating Exercises and Tests

This guide describes how to create exercise files and their corresponding tests in this project, following the established patterns.

## üìã General Structure

### Exercise Files
- **Location**: `exercises/exercises_N.py` where `N` is the exercise number
- **Naming pattern**: `exercises_N.py` (e.g., `exercises_1.py`, `exercises_2.py`)

### Test Files
- **Location**: `_tests/test_exercises_N.py` where `N` corresponds to the exercise number
- **Naming pattern**: `test_exercises_N.py` (e.g., `test_exercises_1.py`, `test_exercises_2.py`)

## üéØ Exercise Patterns

### Pattern 1: Generator Function with `yield` (exercises_1.py, exercises_2.py)

This pattern is used when exercises require students to complete functions or return specific values.

#### Exercise file structure:

```python
from typing import Any

def generator_function_name() -> Any:
    """
    Explanatory documentation for the exercise set.
    Describes the context, objectives, and how to solve them.
    """
    
    # Exercise 1: Clear description of what it should do
    # Include specific constraints or requirements
    def exercise_function_name(param1: type1, param2: type2) -> return_type:
        return default_value  # Placeholder value
    
    yield exercise_function_name
    
    # Exercise 2: Next exercise...
    def another_function(param: type) -> return_type:
        return default_value
    
    yield another_function
```

#### Corresponding test file structure:

```python
from _utilities import get_annotations_and_rvalues
from exercises.exercises_N import generator_function_name

# Create the generator
ordered_answers = generator_function_name()

def _get_next_answer():
    """Helper to get the next answer from the generator"""
    try:
        if ordered_answers is not None:
            return next(ordered_answers)
    except StopIteration:
        print("No more answers")

# Get function from exercise 1
function_exercise_1 = _get_next_answer()
source_exercise_1 = get_annotations_and_rvalues(function_exercise_1)

# Functionality test
def test_exercise_1_functionality():
    if function_exercise_1 is not None:
        assert function_exercise_1(value1) == expected_result, "Descriptive message"
        assert function_exercise_1(value2) == expected_result2, "Descriptive message"
    else:
        assert False, "Exercise 1 function not found"

# Requirements test (verifies that it uses certain structures/keywords)
def test_exercise_1_requirements():
    if (source := source_exercise_1["_source"]) is not None:
        assert "keyword" in source, "Must use 'keyword' in the function"
        assert "other_word" not in source, "Must not use 'other_word'"
    else:
        assert False, "Exercise 1 function not found"

# Repeat for each exercise...
```

### Pattern 2: Direct Functions (exercises_3.py)

This pattern is used when exercises are independent functions that are imported directly.

#### Exercise file structure:

```python
"""
Module documentation explaining the topic and subtopics.
"""

# Necessary imports
from typing import Any

# Example code or context (optional)
example = "reference code"

# Exercise 1: Function to complete
def exercise_function_name_1(param1: type1) -> return_type:
    """
    Docstring explaining what the function should do.
    """
    # Placeholder or incomplete code
    pass

# Exercise 2: Another function
def exercise_function_name_2(param: type) -> return_type:
    pass
```

#### Corresponding test file structure:

```python
from exercises import exercises_N as mod
from exercises.exercises_N import specific_function

# Direct test of imported function
def test_function_name():
    assert specific_function(value) == expected_result, "Message"

# Test of module function
def test_another_function():
    try:
        another_function = mod.another_function  # type: ignore # noqa
    except ImportError as e:
        assert False, f"Could not import function: {e}"
    assert another_function(value) == expected_result
```

## üîß Available Utilities

### `get_annotations_and_rvalues(fn)`

Function from `_utilities` that extracts information from a function's source code:

- **Returns**: A dictionary with:
  - Keys: variable names found in the function
  - Values: `[annotated_type, assigned_value]`
  - `"_source"`: complete source code of the function

**Typical usage**:
```python
source_info = get_annotations_and_rvalues(exercise_function)
source_code = source_info["_source"]  # To verify keywords
type_annotation = source_info["variable"][0]  # Annotated type
value = source_info["variable"][1]  # Assigned value
```

## üìù Creation Process from Topic and Subtopics

### Step 1: Define the Main Topic

Example: "Conditional Structures", "Collections", "Functions", etc.

### Step 2: Identify Subtopics

Each subtopic becomes one or more exercises. Example:
- Topic: "Conditional Structures"
  - Subtopic 1: `if` without `else`
  - Subtopic 2: `if` with `else`
  - Subtopic 3: `if`, `elif`, `else`
  - Subtopic 4: `match`/`case`

### Step 3: Create the Exercise File

1. **Choose the pattern** (generator or direct functions)
2. **Write documentation** explaining the topic and context
3. **Create each exercise**:
   - Function with descriptive name (lowercase letters: `a`, `b`, `c` or descriptive names)
   - Complete type hints
   - Placeholder return value
   - Clear requirement comment
   - If using generator pattern: `yield` the function

### Step 4: Create the Test File

1. **Import** the generator function or module according to the pattern
2. **For each exercise**, create:
   - **Functionality test**: Verifies that the function returns correct values with different inputs
   - **Requirements test**: Verifies that the source code contains/does not contain certain keywords or structures
3. **Use `_get_next_answer()`** if it's a generator pattern to get functions in order
4. **Use `get_annotations_and_rvalues()`** to verify source code when necessary

## ‚úÖ Creation Checklist

### Exercise File
- [ ] File name follows the pattern `exercises_N.py`
- [ ] Generator function or direct functions well defined
- [ ] Clear documentation of topic and objectives
- [ ] Each exercise has:
  - [ ] Clear requirement comment
  - [ ] Complete type hints
  - [ ] Appropriate placeholder return value
  - [ ] Descriptive name or following convention (a, b, c...)
- [ ] If using generator: each function has its `yield`
- [ ] For external libraries:
  - [ ] Data directory `exercises_N_data/` created with `__init__.py`
  - [ ] Dataset files (CSV, etc.) included in data directory
  - [ ] File paths use `os.path` for robustness
  - [ ] Type hints match library conventions (`np.ndarray`, `pd.DataFrame`, etc.)
  - [ ] Return types are correct (`None` for matplotlib, appropriate types for others)

### Test File
- [ ] File name follows the pattern `test_exercises_N.py`
- [ ] Correctly imports from `exercises.exercises_N`
- [ ] For each exercise has:
  - [ ] Functionality test with multiple cases
  - [ ] Requirements test (if applicable) verifying source code
  - [ ] Descriptive error messages in Spanish
- [ ] Uses `_get_next_answer()` if it's a generator pattern
- [ ] Handles cases where the function doesn't exist (`if function is not None`)
- [ ] For external libraries:
  - [ ] Uses appropriate comparison methods (`np.array_equal()` for arrays)
  - [ ] Checks instance types (`isinstance(result, pd.DataFrame)`)
  - [ ] For matplotlib functions, tests that they execute without errors

## üé® Best Practices

### Function Names
- **Simple exercises**: Use letters `a`, `b`, `c`, `d`...
- **Complex exercises**: Use descriptive names like `get_first_element`, `make_dict`

### Comments and Requirements
- Write in Spanish
- Be specific about what the function should do
- Mention constraints (e.g., "Must use `if` without `else`")
- Include examples when useful

### Tests
- **Test cases**: Include normal cases, edge cases, and error cases
- **Messages**: Always in Spanish, descriptive of the problem
- **Code verification**: Use `get_annotations_and_rvalues()` to verify:
  - Presence/absence of keywords (`if`, `else`, `for`, `while`, etc.)
  - Use of specific structures (`match`, `case`, `continue`, etc.)
  - Calls to previous functions (verify `(` and `)` in the code)

### Exercise Order
- From simple to complex
- Each exercise can depend on previous concepts
- Group related exercises by subtopic

### External Libraries and Data Files
- **Data organization**: Create `exercises_N_data/` directory for datasets
- **File paths**: Always use `os.path.join()` with `__file__` for robust paths
- **CSV files**: Include at least 6 columns and 50+ rows for meaningful exercises
- **Module structure**: Add `__init__.py` to data directories
- **Type consistency**: Ensure return types match library conventions:
  - NumPy: `np.ndarray`, `float`, `int`, `tuple[int, ...]` for shapes
  - Pandas: `pd.DataFrame`, `pd.Series`
  - Matplotlib: `None` (visualization functions)

### Pattern 3: External Libraries (exercises_5.py)

This pattern is used when exercises involve external libraries like numpy, pandas, matplotlib, etc.

#### Exercise file structure:

```python
"""
Module documentation explaining the topic and external libraries used.
"""

# Importaciones necesarias
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import Any
import os

# Ruta al dataset (relativa al directorio del archivo)
_current_dir = os.path.dirname(os.path.abspath(__file__))
DATASET_PATH = os.path.join(_current_dir, "exercises_N_data", "dataset.csv")

# Exercise 1: Function with numpy
def numpy_ejercicio_1(arr: np.ndarray) -> float:
    """
    Docstring explaining what the function should do.
    """
    return 0.0

# Exercise 2: Function with pandas
def pandas_ejercicio_1() -> pd.DataFrame:
    """
    Docstring explaining what the function should do.
    """
    return pd.DataFrame()

# Exercise 3: Function with matplotlib (returns None)
def matplotlib_ejercicio_1(x: list[float], y: list[float]) -> None:
    """
    Docstring explaining what the function should do.
    """
    pass
```

#### Key considerations for external libraries:

1. **File paths**: Always use `os.path` to create robust relative paths:
   ```python
   _current_dir = os.path.dirname(os.path.abspath(__file__))
   DATASET_PATH = os.path.join(_current_dir, "exercises_N_data", "dataset.csv")
   ```

2. **Data directories**: Create a subdirectory `exercises_N_data/` for datasets:
   - Include an `__init__.py` file to make it a Python module
   - Place CSV or other data files in this directory
   - Use descriptive names like `dataset.csv`

3. **Type hints for external libraries**:
   - `np.ndarray` for numpy arrays
   - `pd.DataFrame` for pandas DataFrames
   - `pd.Series` for pandas Series
   - `tuple[int, ...]` for tuples of variable length (e.g., array shapes)
   - `None` for matplotlib functions that only create plots

4. **Return types**:
   - NumPy functions: Return `np.ndarray` or primitive types (`float`, `int`)
   - Pandas functions: Return `pd.DataFrame` or `pd.Series`
   - Matplotlib functions: Return `None` (they create visualizations)

5. **Placeholder return values**:
   - NumPy: `np.array([])` for arrays, `0.0` for floats
   - Pandas: `pd.DataFrame()` for DataFrames, `pd.Series()` for Series
   - Matplotlib: `pass` (functions return `None`)

#### Corresponding test file structure:

```python
import numpy as np
import pandas as pd
from exercises import exercises_N as mod

# Test for numpy function
def test_numpy_ejercicio_1():
    try:
        func = mod.numpy_ejercicio_1  # type: ignore # noqa
    except ImportError:
        assert False, "No se pudo importar la funci√≥n"
    
    arr = np.array([1, 2, 3, 4, 5])
    result = func(arr)
    assert result == 3.0, "Mensaje descriptivo en espa√±ol"

# Test for pandas function
def test_pandas_ejercicio_1():
    try:
        func = mod.pandas_ejercicio_1  # type: ignore # noqa
    except ImportError:
        assert False, "No se pudo importar la funci√≥n"
    
    result = func()
    assert isinstance(result, pd.DataFrame), "Debe retornar un DataFrame"
    assert len(result) > 0, "El DataFrame no deber√≠a estar vac√≠o"

# Test for matplotlib function (no return value)
def test_matplotlib_ejercicio_1():
    try:
        func = mod.matplotlib_ejercicio_1  # type: ignore # noqa
    except ImportError:
        assert False, "No se pudo importar la funci√≥n"
    
    x = [1, 2, 3, 4, 5]
    y = [2, 4, 6, 8, 10]
    
    # La funci√≥n no retorna nada, solo verificar que no lance error
    try:
        func(x, y)
    except Exception as e:
        assert False, f"La funci√≥n deber√≠a ejecutarse sin errores, pero lanz√≥: {e}"
```

#### Special considerations for tests with external libraries:

1. **NumPy arrays**: Use `np.array_equal()` to compare arrays, not `==`
2. **Pandas DataFrames**: Check `isinstance(result, pd.DataFrame)` and verify columns/content
3. **Pandas Series**: Check `isinstance(result, pd.Series)` and verify values
4. **Matplotlib functions**: Test that they execute without errors (they return `None`)
5. **Variable-length tuples**: Use `tuple[int, ...]` type hint for shapes that can vary (1D: `(5,)`, 2D: `(3, 2)`, etc.)

## üìö Reference Examples

- **Simple Generator Pattern**: `exercises_1.py` / `test_exercises_1.py`
- **Generator Pattern with Functions**: `exercises_2.py` / `test_exercises_2.py`
- **Direct Functions Pattern**: `exercises_3.py` / `test_exercises_3.py`
- **External Libraries Pattern**: `exercises_5.py` / `test_exercises_5.py`

## üîç Verification

Before considering exercises and tests complete:

1. Run the tests: `pytest _tests/test_exercises_N.py`
2. Verify that all tests pass with correct solutions
3. Verify that tests fail appropriately with incorrect solutions
4. Review that error messages are clear and useful
5. **For external libraries**: Verify type consistency between exercises and tests:
   - Check that return types match what tests expect
   - Ensure `tuple[int, ...]` is used for variable-length tuples (not `tuple[int, int]`)
   - Verify that matplotlib functions return `None`
   - Confirm that numpy/pandas types are correctly annotated

## ‚ö†Ô∏è Common Pitfalls

### Type Hints
- ‚ùå **Wrong**: `tuple[int, int]` for array shapes (only works for 2D arrays)
- ‚úÖ **Correct**: `tuple[int, ...]` for array shapes (works for 1D, 2D, 3D, etc.)

- ‚ùå **Wrong**: `list` for numpy arrays
- ‚úÖ **Correct**: `np.ndarray` for numpy arrays

- ‚ùå **Wrong**: `dict` for pandas DataFrames
- ‚úÖ **Correct**: `pd.DataFrame` for pandas DataFrames

### File Paths
- ‚ùå **Wrong**: `"exercises/exercises_N_data/dataset.csv"` (hardcoded relative path)
- ‚úÖ **Correct**: Use `os.path.join()` with `__file__` for robust paths

### Return Values
- ‚ùå **Wrong**: Returning a value from matplotlib functions
- ‚úÖ **Correct**: Matplotlib functions should return `None` and use `pass` as placeholder

### Tests
- ‚ùå **Wrong**: Using `==` to compare numpy arrays
- ‚úÖ **Correct**: Use `np.array_equal()` for numpy array comparison

- ‚ùå **Wrong**: Testing return value of matplotlib functions
- ‚úÖ **Correct**: Test that matplotlib functions execute without errors
